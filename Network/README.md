# 단권화

## OSI 7 Layer

- 예전에는 네트워크 간 데이터를 통신을 위한 규약이 존재하지 않아, 같은 벤더사의 제품끼리만 통신이 가능했다.
- 이를, 표준화하여 규약으로 만든게 OSI 7 계층이며, 각 계층은 모듈화 되어 있어 독립적인 관계를 가진다.

### 응용 계층(Application)

- 애플리케이션 간 데이터를 전달하기 위한 계층입니다.
- 데이터의 종류에 따라, HTTP, FTP 등의 프로토콜이 사용됩니다.

### 표현 계층(Presentation)

- 데이터의 크기를 줄이기 위해 압축을 선택적으로 할 수 있습니다.
- 데이터의 포맷(JPG, PNG)를 결정하며, 인코딩/디코딩 작업을 수행합니다.

### 세션 계층(Session)

- 네트워크 간 세션을 연결, 유지, 종료를 관리합니다.
- 세션 연결은 **포트** 기반으로 진행됩니다.

### 전송 계층(Transport)

- 포트 주소를 기반으로 다른 네트워크에 **특정 응용프로그램**에 데이터가 정확하게 보내기 위한 계층입니다.
- 데이터의 정확성을 보장하기 위해서는 TCP, 효율성을 보장하기 위해서는 UDP 프로토콜이 사용됩니다.

### 네트워크 계층(Network)

- IP 주소를 기반으로 라우터를 통해 다른 네트워크 상의 컴퓨터에게 데이터를 전달하기 위한 계층입니다.
- 여기서, 라우팅은 데이터 전달을 위해 최적의 경로를 찾는 행위를 의미합니다.

### 데이터 링크 계층(Data Link)

- MAC 주소를 기반으로 LAN 상에서 다른 컴퓨터에게 데이터를 전달하기 위한 계층입니다.
- 데이터 전송 과정에서 오류가 있으면 재전송을 합니다.

### 물리 계층(Phsyical)

- 헤더 및 트레일러가 포함된 비트열을, 내장된 랜카드를 통해 전기 신호로 변환하여 데이터를 전송합니다.

### 세그먼트(Segment)

- 전송계층에서 데이터에 TCP헤더 혹은 UDP가 추가된 데이터를 의미합니다.
- TCP 헤더에는 출발지 포트, 도착지 포트, 버퍼 크기를 나타내는 윈도우 사이즈, 3-way 핸드셰이크를 위한 부호 비트가 있습니다.

### 패킷(Packet)

- 네트워크 계층에서 IP 헤더가 추가된 세그먼트를 의미합니다.
- IP 헤더에는 출발지 및 도착지 IP 주소가 있어, 이를 통해 다른 네트워크의 컴퓨터와 통신을 할 수 있습니다.

### 프레임(Frame) - 데이터 링크

- 데이터 링크 계층에서 이더넷 헤더 및 이더넷 트레일러가 추가된 패킷을 의미한다.
- 이더넷 헤더에는 출발지, 도착지 MAC 주소가 있어 LAN 상에서 도착지 컴퓨터를 찾을 수 있다.
- 단, MAC 주소가 자신의 MAC주소와 다른 경우 역캡슐화를 하지 않고 데이터를 파기한다.
- 수신측이 가지고 있는 FCS와 송신 프레임의 FCS의 동일 여부를 파악하여 에러 여부를 확인한다.

### 데이터그램 vs 패킷이 무슨 차이가 있는지?

- 데이터 그램 : UDP 헤더가 붙은 세그먼트
- 패킷 : TCP 헤더가 붙은 세그먼트

## HTTP

- 클라이언트와 서버가 애플리케이션 계층에서 데이터 전달을 위한 프로토콜입니다.
- HTTP는 상태 및 연결을 유지 하지 않아 스케일 아웃에 유리하며, 송신자, 수신자를 별도로 검증하지 않아 보안적인 이슈가 발생할 수 있습니다.

## GET vs POST

- GET은 자원을 요청하는 메소드입니다.
- POST는 GET과 달리, 자원을 전달하여 서버 상에서 특정 행위를 하는 메소드입니다.
- GET은 멱등성을 보장하는 반면, POST는 멱등성을 보장하지 않습니다.

## HTTP 요청, 응답 헤더

- HTTP 요청(Request) 헤더는 서버로 데이터를 전달하거나, 데이터를 요청할 때 원하는 정보를 담는다.
- HTTP 응답(Respoonse) 헤더는 HTTP 요청에 대한 응답이 담겨 있다.
- 예를 들어, 상태 코드로 요청의 성공 여부를 확인한다.

## HTTP VS HTTPS

- HTTP는 송신, 수신자를 별도로 확인하지 않아 위장의 위험이 있습니다. 그리고, 메시지 바디를 암호화하지 않고, 메시지의 완정성을 보장하지 않기 때문에 변조의 위험이 있습니다.
- 이를 해결하기 위해, 표현 계층의 SSL 혹은 TLS 프로토콜을 통해 데이터를 암호화하여 데이터의 도청 및 변조를 방지할 수 있다.
- HTTPS를 사용하면 브라우저에서 SEO의 점수가 높아지며, 데이터 전송간 보안을 확보할 수 있습니다. 하지만 SSL 핸드셰이크 및 데이터 전송 과정에서 복호화 및 암호화의 오버헤드가 발생합니다.

> Q. HTTPS를 사용하면 헤더도 암호화가 되나요??
> 

## HTTPS 동작 원리

- 비대칭키는 대칭키에 비해 안전하지만 속도가 느리다. 그렇기 때문에, 데이터를 주고 받는 과정에서 비대칭키를 사용한다면 성능 이슈로 이어질 수 있음. 이를 해결하기 위해, 연결 과정에서는 비대칭키를, 데이터를 주고 받는 과정에서는 대칭키로 암호화 하여 통신한다.
- 그렇다면, 어떻게 클라이언트와 서버간에 대칭키를 안전하게 전달할지가 중요하다.
- CA가 존재하는 이유는, **서버의 공개키가 과연 진짜 서버의 것인지를 확인하는 것**이다.

## TSL/SSL handshake

1. 클라이언트 → 서버 : SSL 통신을 시작하며, 클라이언트의 SSL 버전, 암호화 알고리즘, 키 크기 등에 대한 정보를 보냄
2. 서버 → 클라이언트 : SSL 통신이 가능한 경우, 클라이언트로 부터 받은 암호화 알고리즘, 키 크기, SSL 버전 등을 결정하여 응답함.
3. 서버 → 클라이언트 : 공개키 증명서를 보냄
4. 서버 → 클라이언트 : SSL 네고시에이션 종료
5. 최초 네고시에이션 과정이 종료 후, 서버의 공개키로 암호화 한 Pre-Master secret 키를 전달하여 서버가 올바르게 복호화 할 수 있는지 확인합니다.
6. 서버가 Pre-Master secret 키를 제대로 복호화 할 수 있다면, master secret 키를 전달하여 이후 통신은 해당 공통키로 데이터를 암호화 하여 통신을 진행합니다.

## REST

- Representational State Transfer의 약자이며, URI와 HTTP 메소드를 통해 객체화된 서비스를 제공하는 것이다. REST는 리소스, 메서드, 메시지로 구성됩니다.
- REST에서는 주로 메소드로 GET, POST, DELETE, PUT 을 사용한다.
- 예를 들어, `**“신규 회원 임재욱을 생성했습니다”**`
    - 리소스 : 회원
    - 메소드 : 생성
    - 메시지 : 신규 회원 임재욱

## RESTful API

- URI을 아래의 규칙에 맞게 설계했는지를 통해 확인할 수 있다.
    - 명사를 사용하며, 리스트는 복수형을 사용한다. user-users
    - URI에는 행위가 아닌 **자원을 기입**한다.
- 물론 RFC에 표준으로 등록된 내용은 아니다.


## TCP & UDP

### TCP 3-way handshake

- Client와 Server 간의 연결 수립을 하기 위한 과정
- 패킷 전송 - 수신의 흐름
    1. [Client → Server] SYN(a) 패킷 전달
    2. [Server → Client] ACK(a+1), SYN(b) 패킷 전달
    3. [Client → Server] ACK(b+1) 패킷 전달

### TCP 4-way handshake

- Client와 Server 간의 연결 해제을 하기 위한 과정
- 패킷 전송 - 수신의 흐름
    1. [Client → Server] FIN 요청 플래그 전달
    2. [Server → Client] 
        - ACK 메시지 전달 후 데이터 전송이 끝날 때까지 TIME_OUT됨
        - 데이터 전송이 끝나면 FIN 메시지 전달
    3. [Client → Server] ACK 메시지 전달
    4. [Server] 소켓 연결 close

### TCP vs UDP

|  | TCP | UDP |
| --- | --- | --- |
| 프로토콜 종류 | 연결형 | 비연결형 |
| 신뢰성 보장 여부 | O | X |
| 순차성 보장 여부 | O  | X |
| 키워드 | 전이중(full-duplex), 점대점(point-to-point) | 빠른 전송/수신 속도, 연결 설정 불필요 |

## Socket + Web

### CORS란?

브라우저는 기본적으로 같은 origin 간의 리소스만 공유만 가능한데 다른 origin 간의 리소스 공유를 가능하게 해주는 HTTP-header 기반의 장치

🧐 **CORS Error를 피하려면 어떻게 해야 하나?**

1. (서버) Access-Control-Allow-Origin 설정을 true로 해준다
2. (클라이언트) 클라이언트와 서버 사이에 프록시 서버를 둔다

### Cookie vs Session

|  | Cookie | Session |
| --- | --- | --- |
| 저장장소 | client  | server |
| 크기 | max 4KB | 제한없음 |
| 의존성 | X | cookie에 의존적 |
| 보안 | text file에 저장되어 보안에 취약 | cookie보다는 보안성을 갖추고 있음 |

### Repeater, Hub, Bridge, Switch, Router

`(물리 계층)`

**Repeater**

- 신호가 먼거리로도 전달되게 하기 위해 신호를 원래의 세기로 재생성
- 2 port device

**Hub**

- 연결된 모든 디바이스에 데이터 패킷을 전달
    - multiport device, collision domain = 1
- 데이터 패킷을 전달하기 위한 최적의 경로를 찾을 수 없음

`(링크 계층)`

**Bridge**

- **Repeater**의 기능 + MAC 주소를 기반으로 필터링(origin-dest)하는 기능
- 같은 프로토콜에서 동작하는 두개의 LANs를 연결
- 2 port device

**Switch**

- mulitport Bridge (포트의 개수를 증가시켜 효율성과 성능 향상을 도모)
- 데이터 전송 전에 error checking을 수행해 error가 없는 경우에만 포트로 데이터 전달

`(네트워크 계층)`

**Router**

- Switch와 비슷하지만 MAC 주소 기반이 아닌 IP 주소를 기반으로 라우팅
- LANs와 WANs 연결
- 동적 라우팅 테이블 생성 & broadcast 도메인 기준으로 테이블을 나눔

### [Socket.io](http://Socket.io) vs WebSocket

|  | Socket.io | WebSocket |
| --- | --- | --- |
| 개념 | HTML5 웹 표준 기술,TCP 연결 기반 프로토콜 | WebSocket으로 동작하는 라이브러리(정확하게는 WebSocket뿐만 아니라 다른 방식들도 지원) |
| 통신방식 | full-duplex 통신 지원 | event기반 통신 지원 |
| proxy, load balancer 지원 | 미지원 | 지원 |
| broadcasting 지원 여부 | 미지원 | 지원(room) |
| fallback(차선책) option | 미지원 | 지원(Long Polling) |

### Polling vs Long Polling vs Streaming

**Polling**

- 클라이언트가 서버에 주기적으로 요청하여 결과를 확인하는 방식
- 요청에 대한 서버 부담이 크지 않거나 실시간 메시지 전달이 중요하지 않은 서비스에 경우 적합
- 요청주기를 너무 짧게 설정할 경우 서버에 무리를 줄 수 있음

**Long Polling**

- 요청에 대한 응답을 서버 이벤트 발생 시점에 받는 방식
- 실시간 메시지 전달이 중요하지만 서버의 상태 변경이 빈번하지 않은 서비스에 적합
- polling 방식에 비해 불필요한 트래픽을 덜 유발 → 서버의 응답을 무한정 기다리지 않고 특정 시간 이후에 새로 요청하는 방식으로 구현

**Streaming**

- 요청에 대한 응답을 완료하지 않은 상태에서 데이터를 계속 내려받는 방식
- 응답 마다 다시 요청해야 하는 Long Polling에 비해 효율적이며 서버의 상태 변경이 잦은 경우 유리
- 연결을 길게 맺고 있는 경우 유효성 관리 등의 부담이 발생 → 스트리밍 방식도 보통 특정 주기로 연결을 재설정 하도록 구현

### 웹 통신의 큰 흐름

1. 사용자가 웹 브라우저의 검색창에 특정 사이트의 주소를 검색한다
2. **웹 브라우저**가 **DNS**에게 특정 사이트의 도메인 주소를 요청한다
3. **DNS**가 웹 브라우저에게 사이트의 IP 주소를 응답한다
4. **웹 브라우저**가 IP 주소를 이용하여 **웹 서버**에게 html 문서를 요청(HTTP Request)한다
5. 웹 서버는 바로 웹 페이지를 공급하지 못하고 **웹 어플리케이션 서버**와 **데이터베이스**에서 웹 페이지 작업을 처리한다
6. 작업 처리 결과를 **웹 서버**로 보낸다
7. 웹 서버는 **웹 브라우저**에게 html 문서 결과를 응답한다
8. 웹 브라우저는 화면에 웹 페이지를 출력한다

## Loading Balancing 및 Round Robin

### Loading Balancing

네트워크 트래픽을 여러 서버로 분산시키는 과정으로 애플리케이션의 responsiveness를 향상시킨다. Loading Balancing을 위한 타겟 서버를 결정하는 방법에는 크게 4가지가 있다.

1. Least Connection Method - 가장 적은 connection을 가진 서버
2. Least Response Time Method - 평균 응답시간이 가장 적은 서버
3. Round Robin Method - 모든 서버들을 번갈아가면서 타겟으로 결정
4. IP Hash - client의 IP 주소로 트래픽을 보낼 서버 결정

### DNS Round Robin 방식

- DNS의 주소를 여러 대의 서버 IP 리스트 중에 랜덤하게 하나 혹은 여러개를 선택하여 사용자에게 알려주는 방식
- 사용자들이 여러 대의 서버로 나누어 접속하면서 서버의 부하가 분산되는 방식

### 브라우저 렌더링 방식

1. 주소창에 url을 입력하고 Enter를 누르면 서버에 요청이 전송된다
2. 해당 페이지에 존재하는 여러 자원들(text, image 등등)이 보내진다
3. 브라우저에서는 자원들이 담긴 html과 스타일이 담긴 css를 W3C 명세에 따라 해석한다 (**렌더링 엔진**의 역할)
4. 렌더링 엔진은 html 파싱을 통해 **DOM 트리**를 구축한다
5. css도 html과 마찬가지로 파싱되어 **CSSOM 트리**가 구축된다
6. DOM 트리 + CSSOM 트리를 연결하여 **Render 트리**를 생성한다
7. UI 백엔드가 노드의 기하학적 형태 계산을 통해 노드를 화면에 배치한다
8. 빠른 브라우저 화면 표시를 위해 **레이아웃**과 **페인팅** 과정을 자원을 전송받는대로 진행한다. 페이지 정보를 모두 받고 한꺼번에 진행되지 않고 자원을 기다리면서 전달받은 자원을 화면에 표시하는 작업을 동시에 한다

**🧐  파싱 과정**

> 바이트 > 문자 > 토큰 > 노드
> 

**🧐 리플로우, 리페인트**

> 리플로우 - Layout 과정 다시, 리페인트 - Paint 과정 다시
>
