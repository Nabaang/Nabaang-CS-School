## 운영체제

운영체제란 컴퓨터 시스템 자원(SW, HW) 관리, 시스템 보호 등을 수행하여 사용자의 애플리케이션을 효율적으로 처리하는 **소프트웨어**이다. 여기서 HW 자원은 CPU, 메모리, 프로세서 등이 있고, SW 자원은 파일, 프로세스, 메시지 등이 있다.

## 컴퓨터 시스템의 동작 원리

CPU(프로세서)는 데이터 연산 및 디바이스를 제어한다. 이 두 작업을 **CPU 연산 및 I/O 연산**으로 말할 수 있다. 예를 들어 1+1을 계산하라는 로직은 CPU 연산이며, 사용자가 키보드를 통해 입출력을 처리하는 로직은 I/O 연산이라고 할 수 있다.

I/O 연산은 사용자로부터 입력이 발생하면 바로 처리되는 것이 아니다. 디바이스로부터 입력이 발생하여 데이터를 읽어오면, 각 디바이스마다 존재하는 로컬 버퍼에 데이터가 쌓이고 컨트롤러가 **인터럽트**를 발생시킨다. 

인터럽트가 발생하면 CPU에서 처리되고 있던 프로세스가 중단된다. 이후, 인터럽트의 발생 장소 및 원인 파악하여 인터럽트를 서비스할 것인지 결정한다. 만약 서비스한다면 인터럽트 발생 시 어떻게 처리되는지 정리된 서비스 루틴을 호출하여, 해당 인터럽트 서비스 루틴을 종료 후 CPU 연산이 재개된다. 단, 이때 인터럽트 이전에 실행되고 있던 프로세스가 바로 복구되지 않을 수 있다.

## 프로그램 vs 프로세스
 
프로그램은 **디스크**에 존재하는 코드, 정적 데이터를 가리키며, 아직 메모리를 할당받지 못한 상태를 의미한다. 만약, 메모리가 충분하여 프로그램이 메모리를 할당받으면 프로세스가 된다.

## 프로세스

프로세스란 메모리를 할당받아 실행 중인 프로그램이라고 할 수 있다. 더 자세히 이야기하면, 아래와 같다.

- 커널에 등록되어 커널이 관리하고 있는 작업
- 시스템 자원을 요청 및 할당받을 수 있고, 반납할 수 있는 **능동적인 개체(active entity)**
   - 자원은 커널에 관리하에 프로세스에 할당, 반납 당하는 **수동적인 개체(passive entity)**
- PCB(프로세스 관리 블록)을 할당받은 개체 → 커널에 관리하에 있다는 것
   - 커널이 커널 area에서 PCB를 생성하고 관리하기 때문

## 프로세스 상태

<img src="https://media.vlpt.us/images/odh0112/post/a345b8e7-0d5b-4aad-a79d-3ddf4bc35bc9/aa.png" width="50%" height="50%">

프로세스의 상태는 메모리를 할당받은 active, 할당받지 못한 suspended 상태로 분류할 수 있다. 여기서 active 상태에는 ready, running, asleep(blocked), terminated가 있으며 suspended 상태에는 suspended blocked, suspended ready 상태가 있다.

### `<created>`

디스크의 Job이 커널에 의해 등록되면서 PCB를 할당, 프로세스를 할당하는 단계이다. 커널은 메모리의 용량을 확인하여 충분한 경우 ready 상태로, 부족한 경우 suspended ready로 상태를 전이시킨다.

### `<ready>`

프로세서를 제외하고 메모리, 기타 자원을 모두 할당받은 상태이다. 프로세서를 할당받으면 running 상태로 변경된다.

### `<running>`

프로세서를 할당받아 실행 중인 상태를 의미한다. 이후 3가지 상태로 변경될 수 있다.

- I/O 발생 → 인터럽트로 인해 프로세스가 중단되고 asleep 상태로 변경된다.
- 시간 초과 → 지정된 시간을 초과하여 ready 상태로 변경, reqady queue에 쌓임
   - Ex) 라운드 로빈의 time quantum 초과
- 실행 종료 → 모든 작업을 수행하여 terminiated 상태로 변경

### `<asleep>`

I/O 등의 인터럽트가 발생하여 프로세스가 중단된 상태이다. 인터럽트 서비스 루틴이 종료된 후 ready 상태로 변경된다.

### `<suspended>`

프로세서는 오직 하나의 프로세스에만 할당될 수 있다. 만약 프로세스가 프로세서를 할당받아면 해당 프로세스는 running 상태가 된다. 이와 달리, asleep, ready 상태에는 여러 개의 프로세스가 존재할 수 있다. 

**만약 ready 상태에서 오랫동안 running으로 전이되지 않거나, asleep 상태에서 ready 상태로 전이되지 않는 프로세스**가 있다고 생각해 보자. 두 경우에는 실행되지도 않으면서 메모리를 잡아먹는 경우이다. 이러한 두 경우에는, 다른 프로세스에 비해 우선순위가 낮기 때문에 커널이 해당 프로세스에 대해 메모리를 해제하고 이후 메모리가 충분한 경우에 다시 메모리를 할당한다. 여기서 메모리를 할당 해제하는 행위를 swap-out, 다시 할당하는 행위를 swap-in이라고 한다. 

suspended 상태를 이해하기 위해서는 `가상 메모리`의 `swap device` 개념을 이해해야 한다. 이는 이후의 토픽에서 자세히 알아보자.

## Ref.

-   https://sites.google.com/view/hpclab/courses/operating-system
-   https://operatingsystems.tistory.com/entry/OS-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%ACProcess-Management?category=495588
-   https://eunhyejung.github.io/os/2018/06/29/operatingsystem-study02.html
